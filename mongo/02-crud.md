## Insert
dont have to add _id, it will be autogenerated
insert() also exists
mongoimport -d cars -c carlist --drop --jsonArray

use shop
db.dropDatabase() works even on database that doesnt exists
db.persons.insertOne({})

## Ordered inserts
When adding multiple docs, by default if one documents fails all subsequent docs are not going to be executed. However previous sucessful insert are going to stay.
With oredered false you can continue inserting even if some failed.
```
# default behavior is {ordered: true}
db.hobbies.insertMany([
	{_id: "yoga", name: "yoga"}, 
	{_id: "hiking", name: "hiking"}, 
	{_id: "yoga", name: "yoga"},
	{_id: "cooking", name: "cooking"}
], {ordered: false})
```
## WriteConcern
```
insertOne()

{w: 1, j: undefined}
w - when writing file how many servers have to respond success
j - journal, backup logged what needs to be done. Back up todo list. For example document isnt stored on server. Its still in between.
j - if undefined journal isnt used,

{w: 1, j: true} - respond true if server responds and saved to journal
{w: 1, wtimeout: 200, j: true} - you can also add timeout
```
```
db.persons.insertOne({name: "Chrissy", age: 41}, {writeConcern: {w:0}})
0 - will return false, cause its not waiting for response
1 - is default
```
During many insert docs that succesfully were inserted and some failed wont be rollbacked.
This issue can be resolved via transactions.

## Import
```
mongoimport tv-shows.json -d movieDatabase -c movies --jsonArray --drop

-- drop - if collection exists it will drop it. Otherwise appends
```

# Reading data
Filter search and transform data (transforming operators), cursors.
`db`.`collectionName`.`find(` `{fieldName: value}`, `{}` `}`
`db`.`collectionName`.`find(` `{age: {$gt: 30}}`, `{}` `}`

**Read operators:**
- query operators - for locating data $eq
- projection operators - modify data presentation $
  **Update operators:**
- fields - modify and add additional data. $inc
- arrays
  **Query modifiers:**
- are deprecated
  **Aggregation modifiers:**
- pipeline of stages to shape the data

Insert and delete dont have operators. Actually delete has same as find.

## Query and projection selectors
**Query**
- comparison
- evaluation
- logical
- array
- element
- comments
- geospatial

**Projection**
- $
- $elemMatch
- $meta
- $slice

### Comparison operators
`$eq $ne - $gt $gte - $lt $lte - $in $nin`
**Query top level fields**
```
# returns first movie
db.movies.findOne({})
db.movies.find().pretty()

# find uses equality operators by default
db.movies.find({name:'The Last Ship'}).pretty()
db.movies.find({runtime: 60}).pretty()
db.movies.findOne({runtime: 60})

# uses equalls by default
db.movies.findOne({runtime: 60})
db.movies.findOne({runtime: {$eq: 60}})
# value less/greater than 60
db.movies.find({runtime: {$lt: 60}}).pretty()
db.movies.find({runtime: {$gt: 60}}).pretty()

# value equals to some in the list
db.movies.find({runtime: {$in: [42, 33]}})
# value is not equal to some in the list
db.movies.find({runtime: {$nin: [42, 33]}})
```
**Query embedded fields**
You have to use `.` in `"some.field"` cause `.` is invalid character in JSON.
```
db.movies.find({"rating.average": 4.7})
db.movies.find({"rating.average": {$gt: 5}})
```
**Query arrays**
```
# there is Drama in array.
db.movies.find({genres: "Drama"})
# if you want exact equality
db.movies.find({genres: ["Drama"]})
```
### Logical Operators
**Multiple comparison comparators**
`$or, $nor, $and, $not`
```
# $or
db.movies.find({$or: [
		{"rating.average": {$lt: 5}}, 
		{"rating.average": {$gt: 9.3}}
	]
}).count()

# $and
# and is default operator so we can ignore it
db.movies.find({$and: [{"rating.average" : {$gt: 9}}, {"genres" : "Drama"}]})
db.movies.find({"rating.average" : {$gt: 9}, genres: "Drama"})
```
$and can be ignored but in some drivers this wont work. In case you have multiple conditions on the same field. JSON key with same name will override. So $and is required
```
# $and
db.movies.find({genres: "Drama", genres: "Horror"}).count()
db.movies.find({$and: [{genres: 'Drama'}, {genres: 'Horror'}]}).count()
```
```
# $not - can be replaces in this case with $ne
db.movies.find({runtime: {$not: {$eq: 60}}}).count()
db.movies.find({runtime: {$ne: 60}}).count()
```
### Element operators
`$exists` `$type`
```
 db.users.insertMany([
 {name: "Max", hobbies:[{title: "sports", fr: 3}, {title: "cooking", phone: 123, fr: 6}]},
 {name: "Shawn", phone: "345", age: 30,  hobbies: [{title:"car", fr: 4}]}
 ])

# find where field exists
db.users.find({age: {$exists: true, $gt:29}})
# make sure field is a value and not null
db.users.insertOne({name:"Anna", phone:"789", age:null,  hobbies:[{title: "car", fr: 3}]})
db.users.find({age: {$exists: true}})
db.users.find({age: {$exists: true, $ne: null}})

# search for a field but specific type
db.users.find({phone: {$type: "string"}})
```
### Evaluation operatos
`$regex`
```
# find where word is present
db.movies.find({summary: {$regex: "musical"}})
db.movies.find({summary: {$regex: /musical/}})
```
`$expr`
Compare 2 fields and returns where this is a match
```
db.sales.insertMany([
{volume: 100, target: 120}, 
{volume: 89, target: 80}, 
{volume: 200, target: 177}
])
```
this wont work cause it looks at values alphabetically `"volume"` and `"target"`
`db.sales.find({$expr: {$gt: ["volume", "target"]}})
`
so to look at field names we add `$`. This works in expression and aggregation
```
db.sales.find({$expr: {$gt: ["$volume", "$target"]}})

# jednostavan primer
db.sales.find(
	{$expr: {$gt: [
		{$cond: {if: {$gt: ["$volume", 190]}, then: 190, else: 100}}, 
		"$target"
		]}
	}
)

# slozeniji
db.sales.find(
	{$expr: {$gt: [
		{$cond: {if: {$gte: ["$volume", 190]}, then: {$subtract: ["$volume", 10]}, else: "$volume"}}, "$target"
		]}
	}
)
```
